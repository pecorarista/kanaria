import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.util.stream.Collectors

apply plugin: 'kotlin'
apply plugin: 'application'
apply plugin: 'org.jetbrains.dokka'

dependencies {
    implementation group: 'jaxen', name: 'jaxen', version: '1.1.6'
    implementation group: 'org.dom4j', name: 'dom4j', version: '2.1.1'
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8"
    testImplementation group: 'junit', name: 'junit', version: '4.12'
    testImplementation group: 'org.jetbrains.kotlin', name: 'kotlin-test-junit', version: '1.3.21'
}

dokka {
    outputFormat = 'html'
    outputDirectory = "$buildDir/javadoc"
}

sourceCompatibility = 1.8
mainClassName = ""

apply from: 'jcenter.gradle'

// --------------------------------------------------------------------------

def rustSrcDir = Paths.get("$projectDir/src/main/rust")
def rustPlatforms = [
        // for Windows
        "i686-pc-windows-gnu",
        "x86_64-pc-windows-gnu",
//        // for Mac OSX
//        "i686-apple-darwin",
//        "x86_64-apple-darwin",
//        // for iOS
//        "armv7-apple-ios",
//        "aarch64-apple-ios",
        // for Linux
        "i686-unknown-linux-gnu",
        "x86_64-unknown-linux-gnu",
        // for Linux(arm)
        "arm-unknown-linux-gnueabihf",
        "aarch64-unknown-linux-gnu",
]

task("rustPlatformsInstall") << {
    new RustPlatform(rustSrcDir, rustPlatforms).install()
}

task("rustClean") << {
    new RustPlatform(rustSrcDir, rustPlatforms).clean()
}

task("rustBuildDebug") << {
    new RustPlatform(rustSrcDir, rustPlatforms).build(RustPlatform.BuildMode.Debug)
}

task("rustBuildRelease") << {
    new RustPlatform(rustSrcDir, rustPlatforms).build(RustPlatform.BuildMode.Release)
}

task("rustDeployDebug") << {
    new RustPlatform(rustSrcDir, rustPlatforms).deploy(RustPlatform.BuildMode.Debug)
}

task("rustDeployRelease") << {
    new RustPlatform(rustSrcDir, rustPlatforms).deploy(RustPlatform.BuildMode.Release)
}

tasks["rustBuildDebug"].dependsOn("rustPlatformsInstall")
tasks["rustBuildRelease"].dependsOn("rustPlatformsInstall")
tasks["rustDeployDebug"].dependsOn("rustBuildDebug")
tasks["rustDeployRelease"].dependsOn("rustBuildRelease")

// --------------------------------------------------------------------------

// When building JNI for Android, set the "supportAndroid" flag to true.
// However, setup of Android NDK is necessary separately. You need to get the NDK archive from the developer site and extract it to any location.
// Developer site (NDK download page):
// https://developer.android.com/ndk/downloads/
def supportAndroid = true

if (supportAndroid) {
    // It is necessary to set the path which expanded the archive of NDK.
    def androidNdkHome = Paths.get(
            // For example, when using Windows
            // "C:\\android-ndk-r19c"
            // For example, when using Linux
            "~/android-ndk-r19c/"
    )

    def rustAndroidPlatforms = [
            // for Android
            "i686-linux-android",
            "x86_64-linux-android",
            "armv7-linux-androideabi",
            "aarch64-linux-android",
    ]

    task("rustAndroidPlatformsInstall") << {
        new AndroidNdkPlatform(rustSrcDir, rustAndroidPlatforms, androidNdkHome).install()
    }

    task("rustBuildAndroidDebug") << {
        new AndroidNdkPlatform(rustSrcDir, rustAndroidPlatforms, androidNdkHome).build(RustPlatform.BuildMode.Debug)
    }

    task("rustBuildAndroidRelease") << {
        new AndroidNdkPlatform(rustSrcDir, rustAndroidPlatforms, androidNdkHome).build(RustPlatform.BuildMode.Release)
    }

    task("rustDeployAndroidDebug") << {
        new AndroidNdkPlatform(rustSrcDir, rustAndroidPlatforms, androidNdkHome).deploy(RustPlatform.BuildMode.Debug)
    }

    task("rustDeployAndroidRelease") << {
        new AndroidNdkPlatform(rustSrcDir, rustAndroidPlatforms, androidNdkHome).deploy(RustPlatform.BuildMode.Release)
    }

    tasks["rustBuildAndroidDebug"].dependsOn(["rustPlatformsInstall", "rustAndroidPlatformsInstall"])
    tasks["rustBuildAndroidRelease"].dependsOn(["rustPlatformsInstall", "rustAndroidPlatformsInstall"])
    tasks["rustDeployAndroidDebug"].dependsOn("rustBuildAndroidDebug")
    tasks["rustDeployAndroidRelease"].dependsOn("rustBuildAndroidRelease")
}

// --------------------------------------------------------------------------

class RustPlatform extends AbstractPlatform {
    protected def rustPlatforms = new ArrayList<String>()

    RustPlatform(Path buildTargetPath, List<String> platforms) {
        super(buildTargetPath)
        this.rustPlatforms.addAll(platforms)
    }

    def install() {
        rustPlatforms.forEach {
            run("rustup", "target", "install", it)
        }
        return this
    }

    def build(BuildMode mode) {
        rustPlatforms.forEach {
            if (isWindows() && !it.contains("windows")) {
                println("[$it] The build is running on Windows. Other than platforms for Windows are not supported.")
                return null
            }

            println("[$it] compile start.")
            run("cargo", "build", "--target", it, ((mode == BuildMode.Release) ? "--release" : ""))
            println("[$it] compile finish!")
        }
        return this
    }
    
    def deploy(BuildMode target) {
        rustPlatforms.forEach {
            def filename = it.contains("windows") ? "kanaria_jni.dll" : "libkanaria_jni.so"
            def src = Paths.get("$buildTargetPath/target/$it/${target == BuildMode.Debug ? "debug" : "release"}/$filename")
            if (!src.toFile().exists()) {
                throw new InvalidRustException("lib is not found.")
            }

            def dest = Paths.get("$buildTargetPath/../resources/com/kanaria/platforms/$it/")
            if (dest.toFile().exists()) {
                dest.deleteDir()
            }
            dest.toFile().mkdirs()

            Files.copy(src, Paths.get(dest.toString(), filename.replace(".so", "").replace(".dll", "")))
        }
    }

    def clean() {
        run("cargo", "clean")
    }

    enum BuildMode {
        Debug, Release
    }
}

class AndroidNdkPlatform extends RustPlatform {
    def androidNdkHome = Paths.get("")

    AndroidNdkPlatform(Path buildTargetPath, List<String> rustPlatforms, Path androidNdkHome) {
        super(buildTargetPath, rustPlatforms)
        this.androidNdkHome = androidNdkHome
    }

    @Override
    def install() {
        super.install()

        def makeStandalonePlatformScriptPath = Paths.get(androidNdkHome.toString(), "build", "tools", "make_standalone_platform.py")
        rustPlatforms.forEach {
            def archAlias = getArchAliasForInstall(getArch(it))
            def installPath = Paths.get(buildTargetPath.toString(), "AndroidNDK", archAlias)
            if (Paths.get(installPath.toString(), "AndroidVersion.txt").toFile().exists()) {
                println("[$it : $archAlias] already installed ndk for $archAlias.")
                return null
            }

            println("[$it : $archAlias] install start.")
            run("python", makeStandalonePlatformScriptPath.toString(), "--arch", archAlias, "--api", "26", "--install-dir", installPath.toString())
            println("[$it : $archAlias] install finish!")
        }

        return this
    }

    def build(BuildMode mode) {
        rustPlatforms.forEach {
            if (isWindows() && !it.contains("windows")) {
                println("[$it] The build is running on Windows. Other than platforms for Windows are not supported.")
                return null
            }

            println("[$it] compile start.")

            def pathBuilder = new StringBuilder()
                    .append(System.getenv("PATH"))
                    .append(":")
                    .append(buildTargetPath)
                    .append("/AndroidNDK/")
                    .append(getArchAliasForInstall(getArch(it)))
                    .append("/bin/")

            env.put("PATH", pathBuilder.toString())
            run("cargo", "build", "--target", it, ((mode == BuildMode.Release) ? "--release" : ""))
            println("[$it] compile finish!")
        }
        return this
    }
}

class AbstractPlatform {
    protected def buildTargetPath = Paths.get("")
    protected def env = new HashMap<String, String>()

    AbstractPlatform(Path buildTargetPath) {
        this.buildTargetPath = buildTargetPath
    }

    protected def run(String... command) {
        def outBuffer = new PrintBuffer([(Appendable) System.out])
        def errBuffer = new PrintBuffer([])

        def processBuilder = new ProcessBuilder(
                command.toList()
                        .stream()
                        .filter { !it.isEmpty() }
                        .collect(Collectors.toList())
        )
        processBuilder.environment().putAll(env)

        processBuilder
                .directory(buildTargetPath.toFile())
                .start()
                .waitForProcessOutput(outBuffer, errBuffer)

        def err = errBuffer.toString()
        if (err.contains("error:")) {
            throw new InvalidRustException(err)
        }
    }

    protected static def getFamily() {
        String os = System.getProperty("os.name")
        if (os == null)
            return ""
        else if (os.toLowerCase().startsWith("windows"))
            return "windows"
        else if (os.toLowerCase().startsWith("mac"))
            return "mac"
        else if (os.toLowerCase().startsWith("linux"))
            return "unix"
        return ""
    }

    protected static def isWindows() {
        getFamily() == "windows"
    }

    protected static def isLinux() {
        getFamily() == "linux"
    }

    protected static def isMac() {
        getFamily() == "mac"
    }

    protected static def getArch(String rustPlatformName) {
        rustPlatformName.split('-')[0]
    }

    protected static def getArchAliasForInstall(String arch) {
        switch (arch) {
            case "i686":
                return "x86"
            case "x86_64":
                return "x86_64"
            case "armv7":
                return "arm"
            case "aarch64":
                return "arm64"
            default:
                throw new InvalidRustException("not support arcitecture : $arch")
        }
    }

    protected static def getArchAliasForBuild(String arch) {
        switch (arch) {
            case "i686":
                return "x86"
            case "x86_64":
                return "x86_64"
            case "armv7":
                return "armv7a"
            case "aarch64":
                return "aarch64"
            default:
                throw new InvalidRustException("not support arcitecture : $arch")
        }
    }

    private class PrintBuffer implements Appendable {
        private def buffer = new StringBuffer()
        private def appendable = new ArrayList<Appendable>()

        PrintBuffer(List<Appendable> appendableList) {
            appendable.add(buffer)
            appendable.addAll(appendableList)
        }

        @Override
        Appendable append(CharSequence csq) throws IOException {
            appendable.forEach {
                it.append(csq)
            }
            return this
        }

        @Override
        Appendable append(CharSequence csq, int start, int end) throws IOException {
            appendable.forEach {
                it.append(csq, start, end)
            }
            return this
        }

        @Override
        Appendable append(char c) throws IOException {
            appendable.forEach {
                it.append(c)
            }
            return this
        }

        @Override
        String toString() {
            return buffer.toString()
        }
    }
}

class InvalidRustException extends RuntimeException {
    InvalidRustException(String message) {
        super(message)
    }
}